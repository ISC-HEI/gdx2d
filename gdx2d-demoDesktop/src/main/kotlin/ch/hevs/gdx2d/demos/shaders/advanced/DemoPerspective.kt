package ch.hevs.gdx2d.demos.shaders.advanced

import ch.hevs.gdx2d.components.bitmaps.BitmapImage
import ch.hevs.gdx2d.desktop.PortableApplication
import ch.hevs.gdx2d.lib.GdxGraphics
import ch.hevs.gdx2d.lib.utils.Logger
import com.badlogic.gdx.Gdx
import com.badlogic.gdx.graphics.Pixmap.Format
import com.badlogic.gdx.graphics.glutils.FrameBuffer
import com.badlogic.gdx.math.Vector3

/**
 * Demonstrates how to use a shader to postprocess
 * an image generated by the library. The idea is to generate
 * everything you want in a backbuffer (~ a texture)
 * then copy it to the active buffer and then apply a
 * shader to which the texture data is the rendered image.
 *
 * @author Pierre-Andr√© Mudry
 * @version 1.0
 */
class DemoPerspective : PortableApplication() {
    var time = 0f
    var shaderEnabled = true

    // Used for off screen rendering
    lateinit var fbo: FrameBuffer

    // Standard images used for drawing
    lateinit var imageAndroid: BitmapImage
    lateinit var imageBackground: BitmapImage

    var cameraFov = (Math.PI / 6.0f).toFloat()  //Horizontal field of vision
    var cameraAngle = (Math.PI / 10.0f).toFloat()  //Horizontal field of vision
    var cameraPosition = Vector3(0.0f, -1.0f, 0.02f)
    var cameraAxis = Vector3(1.0f, 0.0f, 0.0f)

    override fun onInit() {
        this.setTitle("Postprocessing with a shader, mui 2013")
        imageAndroid = BitmapImage("images/Android_PI_48x48.png")
        imageBackground = BitmapImage("images/back1_512.png")
        fbo = FrameBuffer(Format.RGBA8888, this.windowWidth, this.windowHeight, false)
        Logger.log("Click to enable/disable shader")
    }

    override fun onGraphicRender(g: GdxGraphics) {
        if (g.shaderRenderer == null) {
            g.setShader("shader/advanced/perspective.fp")
        }

        // Draws some stuff to an offscreen buffer, using normal
        // gdx2d primitives
        fbo.begin()
        g.clear()
        g.drawPicture(256f, 256f, imageBackground)
        g.drawTransformedPicture(256f, 256f, time * 100, 1f, imageAndroid)
        g.drawFPS()
        g.drawSchoolLogo()
        g.sbFlush()
        fbo.end()


        // Copy the offscreen buffer to the displayed bufer
        g.shaderRenderer.setTexture(fbo.colorBufferTexture, 0)
        g.shaderRenderer.setUniform("enabled", shaderEnabled)
        g.shaderRenderer.setUniform("cameraPosition", cameraPosition)
        g.shaderRenderer.setUniform("cameraAxis", cameraAxis)
        g.shaderRenderer.setUniform("screenPlanDistance", (0.5 / Math.atan(cameraFov / 2.0)).toFloat())
        g.shaderRenderer.setUniform("cameraAngle", cameraAngle)

        //Move the camera
        cameraPosition.y *= 1 + 0.1f * Gdx.graphics.deltaTime
        cameraPosition.y -= 0.1f * Gdx.graphics.deltaTime
        cameraPosition.z *= 1 + 0.05f * Gdx.graphics.deltaTime
        cameraPosition.z += (0.05 * Gdx.graphics.deltaTime).toFloat()
        cameraAngle += (0.01 * Gdx.graphics.deltaTime).toFloat()

        time += Gdx.graphics.deltaTime
        g.drawShader(time)
        println(1.0 / Gdx.graphics.deltaTime)
    }

    override fun onClick(x: Int, y: Int, button: Int) {
        super.onClick(x, y, button)
        shaderEnabled = !shaderEnabled
    }

    companion object {

        @JvmStatic
        fun main(args: Array<String>) {
            DemoPerspective()
        }
    }
}
